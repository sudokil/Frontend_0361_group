экспорты:
export let|const|class}function ... - экспортируется объявление переменной/константы/класса/функции
    после экспортированного объявления класса/функции не ставится ;
export {...} - экспортируется список сущностей (имена перечисляются через запятые)
    даже если сущность всего одна, все равно в {}
export {... as ...} - экспортируем с переименованием
export default - экспорт по умолчанию
    может быть использован в одном файле не более одного раза
    можно экспортировать безымянную сущность
export {... as default} - экспортируем нечто под именем default
    разницы в поведении с export default ... не должно быть
export {...} from '...' - реэкспортируем нечто, импортированное из другого модуля
    export * from '...' не реэкспортирует export default
    реэкспорт экспортированного по умолчанию работает только отдельно от реэкспорта всего именованного в виде:
        export {default} from '...'
        export {default as ...} from '...'

импорты:
import {...} from '...' - простой импорт
    даже если импортируется одна сущность, все равно в {}
import {... as ...} from '...' - импорт с переименованием
import ... from '...' - импорт по умолчанию (тут имя может быть любое)
import {default as ...} from '...' - импорт по умолчанию с переименованием
import * as ... from '...' - импорт сразу всего в виде объекта
    если в модуле есть импортируемое по умолчанию, оно становится свойством объекта default
import '...' - просто подключить модуль (его код исполнится, но никуда не будет присвоен

модули:
всегда используется "use strict"
каждый модуль имеет свою собственную область видимости
в хтмл тег пишется с атрибутом типа: <script type="module">
    для старых браузеров можно делать вариант <script nomodule> - современные браузеры этот вариант понимают и пропускают.
при любом количестве вызовов загрузки реально грузится и исполняется только один раз.
в модуле нет this глобального уровня (там не видно window)
модули всегда грузятся как defer, а выполняются только после полной загрузки документа
    но модуль с атрибутом async выполняется сразу как загрузится
для импорта всегда нужно указывать не только имя, но и путь
команды импорта и экспорта не работают внутри {} и не допускают переменных вместо строки пути+адреса.
выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект, содержащий все экспорты модуля.
    это не функция!
    это динамический импорт, он не требует указания <script type="module">
    можно сразу присваивать:
        let {hi, bye} = await import('./say.js');